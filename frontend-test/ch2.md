## 1. 테스트 범위와 목적

- 범위와 목적을 이해해야 테스트 자동화의 장점까지 누릴 수 있다.

### 1.1 테스트 범위

- 웹 애플리케이션은 보통 다음과 같은 모듈을 조합해 만들어진다.
    - 라이브러리가 제공하는 함수
    - 로직을 담당하는 함수
    - UI 관련 함수
    - 웹 API 클라이언트
    - API 서버
    - 데이터베이스 서버

- 프론트엔드 개발의 테스트 범위는 크게 4가지
    - 정적분석
        - 타입스크립트나 ESLint가 제공하는 기능을 활용
    - 단위 테스트
        - 한 가지 모듈에 한정하여 해당 모듈이 제공하는 기능을 검증하는 테스트
        - 실제로 사용할 때는 발생하지 않는 코너 케이스 검증에 적합
    - 통합 테스트
        - 모듈 조합으로 제공되는 기능을 검증하는 테스트
    - E2E 테스트
        - 헤드리스 브라우저와 UI 자동화 도구를 결합하여 검증하는 테스트

### 1.2 테스트 목적

- 테스트 타입은 테스트 목적에 따라 분류된다
- 테스트 타입은 검증 목적에 맞게 설정해야 하며, 타입마다 적절한 도구가 필요
1. 기능 테스트(인터랙션 테스트)
    - 개발된 기능에 문제가 없는지 검증하는 테스트
    - 프런트엔드에서는 UI 컴포넌트 조작(인터랙션)에서 시작하는 기능이 많기 때문에 인터랙션 테스트가 기능 테스트가 될 때가 많다.
2. 비기능 테스트(접근성 테스트)
    - 웹 접근성을 검증하는 테스트
    - 최근에는 웹 접근성 관련 API가 여러 플랫폼에 추가돼 테스트 환경이 잘 갖춰지고 있음
3. 회귀 테스트
    - 특정 시점을 기준으로 전후 차이를 비교해 문제가 있는지 검증하는 테스트
    - UI 컴포넌트를 개발하는 프런트엔드에서는 시각적 회귀 테스트가 중요

## 2 프런트엔드 테스트의 범위

### 2.1 정적 분석

- 타입스크립트를 활용하는 **정적 분석**은 버그를 조기에 발견할 수 있게 해준다.
- 특히, 런타임 작동을 예측해주는 타입 추론이 매우 유용하다.

```jsx
function getMessage(name: string | undefined) {
	const a = name; // a: string | undefined
  if(!name) {
	  return `Hello anonymous!`;
  }
  // if문 분기와 reuturn으로 undefiend가 아니라는 것이 판정
  const b = name; // b: string;
  return `Hello ${name}`;
}
```

- 반환값이 생각한 타입과 일치하는지 검증할 때도

```jsx
function checkType(type: "A" | "B" | "C"): string {
      const message: string = "valid type";
      if(type === "A") {
      	return message;
      }
      if(type === "B") {
      	return message;
      }
      // 예외 발생 처리 유무에 따라 함수의 반환 타입 추론이 바뀐다
      // throw new Error('invalid type');
  }
```

- 코드 가이드라인 제공하는 ESLint 도..

### 2.2 단위 테스트

어쩌면 내가 가장 익숙한, 그리고 유일한..

- 가장 기초적인 테스트
- 모듈이 특정 입력값을 받아 기대하는 출력값을 반환하는지 테스트
- 모듈에 따라 코너 케이스에 한해서만 예외를 발생시키는 것이 나은 경우도 있다
    - 단위 테스트는 어떤 상황에서 예외를 발생시켜야 할지 판단할 때 도움이 된다.

### 2.3 통합 테스트

- 여러 모듈을 연동한 기능을 테스트
- 예를 들어, 목록 화면이 있는 애플리케이션의 동작 시나리오를 생각해보자
    1. 셀렉트 박스를 조작한다.(인터랙션) 
    2. URL 검색 쿼리가 변경된다. 
    3. 검색 쿼리가 변경되어 데이터 취득 API가 호출된다. 
    4. 목록 화면 내용을 갱신한다.
- 1~4 까지 검증하는게 넓은 범위의 통합 테스트
- 코너 케이스로 테스트가 복잡해지면 테스트 범위를 좁혀 테스트 목적을 명확히 할 수 있다.

### 2.4 E2E 테스트

- 외부 스토리지와 같이 연동 중인 하위 시스템을 포함하는 테스트
- 입력 내용에 따라 저장된 값이 갱신되기 때문에 연동된 외부 기능이 정상적으로 작동하는지 검증할 수 있다.

## 3. 프런트엔드 테스트의 목적

### 3.1 기능테스트(인터랙션 테스트)

- 웹 프론트엔드의 기능 테스트는 인터랙션 테스트가 대부분이다
    - 웹 프론트엔드의 주요 개발 대상은 UI 컴포넌트
    - 사용자가 조작하면 상태를 변경하고, 화면을 갱신하는 특성을 갖는다
- 실제 브라우저가 없어도 가능한 인터랙션 테스트 vs 실제 브라우저 환경에서 테스트
    - 맨 아래까지 스크롤을 내리면 추가 데이터를 불러온다
    - 세션 스토리지에 저장된 값을 불러온다

### 3.2 비기능 테스트(접근성 테스트)

- 접근성 테스트는 비기능 테스트의 한 종류다
- 접근성 테스트의 검증 항목 예시
    1. 키보드만으로 웹사이트를 이용할 수 있는가
    2. 명암비가 시인성에 문제는 없는가 → 요소들이 화면에서 잘 구분 되는지
- 접근성 테스트 실제 사례
    1. 키보드로 체크 박스를 체크할 수 있다.
    2. 오류 응답을 받았을 때 오류 문구를 렌더링한다.
    3. 렌더링된 화면에 접근성 위반 사례가 있는지 검사한다.

### 3.3 시각적 회귀 테스트

- 시각적 회귀 테스트는 코드 변경 전후의 UI 차이를 검증하기 위해, 헤드리스 브라우저에서 렌더링된 화면을 캡처해 비교한다.
- CSS는 UI 컴포넌트뿐만 아니라 브라우저 기본 스타일에도 영향을 받으므로 최종 렌더링 결과를 기준으로 테스트해야 한다.
- UI는 사용자 인터랙션에 따라 변경될 수 있기 때문에 초기 화면뿐만 아니라 조작 후 상태까지 캡처해 비교해야 한다.
- 시각적 회귀 테스트 실제 사례
    1. 버튼 스타일에 차이가 없다.
    2. 메뉴 바를 열었을 때 화면에 차이가 없다.
    3. 렌더링된 화면에 차이가 없다.

## 4. 테스트 전략 모델

![image.png](attachment:2fddca7d-1544-405e-aa00-457a9963a135:image.png)

- 위로 갈수록 실제 제품과 유사한 테스트가 가능하다
- 상층부 테스트는 시간과 비용이 필요

### 4.1 아이스크림 콘과 테스트 피라미드

![image.png](attachment:c0d5e8f0-5342-4376-b0c0-9f7af60417b9:image.png)

아이스크림 콘

- 상층부 테스트의 비중이 높은 아이스크림 콘은 안티패턴으로 자주 언급
- 운용 비용도 높고 외부 모듈 의존성 때문에 불안정한 테스트가 비교적 많은 편이다.
- 전체 테스트 통과하는데 시간이 오래 걸릴 수 밖에 없는데 실행 시간을 줄이려고 실행 빈도를 줄이면 신뢰성이 낮아진다

테스트 미라미드

- 하층부 테스트의 비중이 높을수록 더욱 안정적이고 가성비 높은 테스트가 가능하다는 것이 핵심
- 상층부 테스트는 실행 시간이 길어서 신속성이 떨어지지만 하층부 테스트는 신속성이 좋아 자주 실행할 수 있어 안전성도 높다.

### 4.2 테스팅 트로피

![attachment:8feaf313-c68e-4320-9a4f-b20c7814a290:image.png]()

- 통합 테스트 비중이 가장 높아야 한다가 핵심
- 테스팅 라이브러리와 제스트를 사용하면 헤드리스 부라우저 없이도 사용자 조작을 재현해 테스트를 할 수 있어서 실행 속도가 빠르면서도 실제 제품과 유사한 테스트가 가능하다.

## 5. 테스트 전략 계획

- 테스트 전략 모델을 참고해 프로젝트에 최적인 전략을 수립하려면..
    - 테스트 대상 및 목적에 따른 판단 기준을 정립해야 한다

### 5.1 테스트가 없어 리팩토링이 불안한 경우

- 일단 릴리스된 기능을 목록으로 정리하고 회귀 테스트 작성
    
    → 안심하고 리팩터링 시작할 수 있음
    
- 만일, 웹 API 서버에 대한 의존성이 분리되지 않아서 테스트 작성이 어렵다면 목 서버를 활용해 통합 테스트(7장)를 실시한다.
- 목 서버를 활용하면 구현 코드를 수정하지 않아도 테스트할 수 있어 리팩터링 시작 전에 테스트를 작성하기 좋음

### 5.2. 반응형으로 제작된 프로젝트

- 테스팅 라이브러리만으로는 반응형 웹의 스타일까지 포함한 세밀한 테스트를 진행하기 어렵다.
- 브라우저를 사용한 시각적 회귀 테스트가 필요
- 반응형으로 프로젝트를 제작한다면 스토리북을 사용해서 테스트를 작성하는 것이 효율적

### 5.3. 데이터베이스를 포함한 E2E 테스트가 필요한 경우

- 실제 웹 API 서버를 사용해서 E2E 테스트를 하고 싶다면 테스트용 ****스테이징 환경을 사용해야 한다.
    
    스테이징 환경: 실제로 배포할 환경에 가까운 형태로 만든 테스트용 환경
    
    - 프로젝트 릴리스 전에 테스트 계획서 보면서 수동으로 진행
    - 브라우저를 사용한 UI 자동화 방식으로 테스트
        
        → 아이스크림 콘 모델에 가까운 테스트 전략이 되기 쉬우니 조심
        
- 스테이징 환경 없이 실행 가능한 테스트 자동화 방법도 있다
    - 테스트할 시스템을 컨테이너화해 CI 환경에서 실행한 후 연동 중인 여러 시스템과 함께 테스트
    - 비교적 환경 구축 비용이 적고 개발자 혼자서도 구축할 수 있는 장점
`